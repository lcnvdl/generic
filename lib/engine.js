/*

Generated by JsBuild
http://www.lucianorasente.com.ar

Date: 28/06/2014 
Files:
    consolelog.min.js
    def.js
    math.js
    misc.js
    string.js
    iidentificable.js
    eventmanager.js
    events.js
    engine.js
    color.js
    component.js
    clock.js
    entity.js
    module.js
    resource.js
    resourcecontainer.js
    resourcequeue.js
    scene.js
    path.js
    input.js
    inputaction.js
    inputdevice.js
    inputdevicemap.js
    inputmanager.js
    inputmap.js
    inputtypes.js
    joypad.js
    keyboard.js
    kinect.js
    mouse.js
    touchscreen.js

*/

/*global log:false*/// Tell IE9 to use its built-in console
Function.prototype.bind&&(typeof console=="object"||typeof console=="function")&&typeof console.log=="object"&&["log","info","warn","error","assert","dir","clear","profile","profileEnd"].forEach(function(method){console[method]=this.call(console[method],console)},Function.prototype.bind);window.log||(window.log=function(){var ua,winRegexp,script,i,args=arguments,isReallyIE8=!1,isReallyIE8Plus=!1;log.history=log.history||[];log.history.push(arguments);if(log.detailPrint&&log.needDetailPrint){ua=navigator.userAgent;winRegexp=/Windows\sNT\s(\d+\.\d+)/;console&&console.log&&/MSIE\s(\d+)/.test(ua)&&winRegexp.test(ua)&&parseFloat(winRegexp.exec(ua)[1])>=6.1&&(isReallyIE8Plus=!0)}if(isReallyIE8Plus||typeof console!="undefined"&&typeof console.log=="function")if(log.detailPrint&&log.needDetailPrint&&log.needDetailPrint()){console.log("-----------------");args=log.detailPrint(args);i=0;while(i<args.length){console.log(args[i]);i++}}else Array.prototype.slice.call(args).length===1&&typeof Array.prototype.slice.call(args)[0]=="string"?console.log(Array.prototype.slice.call(args).toString()):console.log(Array.prototype.slice.call(args));else if(!Function.prototype.bind&&typeof console!="undefined"&&typeof console.log=="object")if(log.detailPrint){Function.prototype.call.call(console.log,console,Array.prototype.slice.call(["-----------------"]));args=log.detailPrint(args);i=0;while(i<args.length){Function.prototype.call.call(console.log,console,Array.prototype.slice.call([args[i]]));i++}}else Function.prototype.call.call(console.log,console,Array.prototype.slice.call(args));else if(!document.getElementById("firebug-lite")){script=document.createElement("script");script.type="text/javascript";script.id="firebug-lite";script.src="https://getfirebug.com/firebug-lite.js";document.getElementsByTagName("HEAD")[0].appendChild(script);setTimeout(function(){window.log.apply(window,args)},2e3)}else setTimeout(function(){window.log.apply(window,args)},500)});

/* ****************************
  Declarations
 ****************************** */

var GE = GE || {};

GE.defaults = {
    LISTENER_PREFIX: "gengine_ev_",
    MAX_PLAYERS: 1
};

GE.Debug = false;

GE.jQuery = jQuery || $;

if(!GE.jQuery) {
    throw "jQuery is required.";
}

if(typeof dejavu === 'undefined') {
    throw "dejavu is required.";
}

GE.Klass = dejavu.Class.declare;
GE.Abstract = dejavu.AbstractClass.declare;
GE.Interface = dejavu.Interface.declare;

/**
 * Is a instance of b.
 *
 * @param a
 * @param b
 * @returns {boolean}
 */
GE.is = function(a, b) {
    return dejavu.instanceOf(a, b);
};

/**
 * Is a instance of GE.Entity.
 * @param a
 * @returns {boolean}
 */
GE.isEntity = function(a) {
    return GE.is(a, GE.Entity);
};

/* ****************************
 Browsers compatibility
 ****************************** */

if (!Object.keys) {
    Object.keys = function (obj) {
        var keys = [], k;
        for (k in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, k)) {
                keys.push(k);
            }
        }
        return keys;
    };
}

/* ******************************
 Misc
 ******************************** */

/**
 * Creates an alias for a variable.
 * @param {*} klass Variable or class.
 * @param {string} as Alias.
 */
GE.using = function(klass, as) {

    if(typeof as !== 'string') {
        throw "GE.using(Object, String)";
    }

    if(window[as]) {
        throw "Global "+as+ " already exists";
    }

    window[as] = AGE.Res.Model;
};

GE.efp =
GE.entityFromParam = function(xyz) {
    var result,
        scene = GE.engine.getCurrentScene();

    if(typeof xyz === 'string') {
        result = scene.findObject(xyz);
    }
    else if(typeof xyz === 'number') {
        result = scene.getObject(xyz);
    }
    else {
        result = xyz;
    }

    return result;
};

GE.sizeOf = function(obj) {

    if(typeof obj === 'array') {
        return obj.length;
    }

    var size = 0, key;
    for (key in obj) {
        if (obj.hasOwnProperty(key)) size++;
    }
    return size;
};


GE.loadScript = function (url) {

    if(GE.Debug)
        console.log("Getting script: "+url);

    return GE.jQuery.ajax({
        url: url,
        dataType: 'script',
        cache: true
    });
}

/* ****************************
    Math extension
 ****************************** */

/**
 *	Math lerp.
 *
 *	@method Math.lerp
 *	@param {float} a Current value.
 *	@param {float} b Target value.
 *	@param {float} x Percent/100 (value between 0.0 and 1.0).
 *	@static
 *	@return {float} result
 **/
Math.lerp = Math.lerp || function(a, b, x) {
    return a + x * (b - a);
};

Math.toRad = Math.toRad || function(deg) {
    return deg * Math.PI / 180;
};

Math.toDeg = Math.toDeg || function(rad) {
    return rad * 180 / Math.PI;
};

Math.sign = Math.sign || function(x) {
    return typeof x == 'number' ? x ? x < 0 ? -1 : 1 : isNaN(x) ? NaN : 0 : NaN;
};

Math.sqr = Math.sqr || function(x) {
    return x*x;
};

Math.choose = Math.choose || function() {

    var arr;

    if(arguments.length > 1) {
        arr = arguments;
    }
    else if(GE.jQuery.isArray(arguments[0])) {
        arr = arguments[0];
    }
    else {
        return arguments[0];
    }

    return arr[Math.floor(Math.random() * arr.length)];
};

/* ****************************
 Game helpers
 ****************************** */

Math.dist = Math.dist || function(x1, y1, x2, y2) {
    return Math.sqrt(Math.sqr(x2 - x1) + Math.sqr(y2 - y1));
};

Math.dist3 = Math.dist3 || function(x1, y1, z1, x2, y2, z2) {
    return Math.sqrt(Math.sqr(x2 - x1) + Math.sqr(y2 - y1) + Math.sqr(z2 - z1));
};

Math.angle = Math.angle || function(x1, y1, x2, y2) {
    throw "Not implemented";
};

Math.angle3 = Math.angle || function(x1, y1, z1, x2, y2, z2) {
    throw "Not implemented";
};

GE.Misc = {

    //
    //  Color
    //

    /**
     * Returns a random color.
     * @returns {Number} A random hexadecimal color.
     */
    getRandomColor: function() {
        return Math.floor(Math.random() * 16777215);
    },

    //
    //  Canvas
    //

    wrapText: function(context, text, maxWidth) {

        // TODO: fix when a single word's with > maxWidth

        var words = text.split(' ');
        var line = '';
        var result = '';

        for(var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = context.measureText(testLine);
            var testWidth = metrics.width;

            if (testWidth > maxWidth && n > 0) {
                result += line + "\n";
                line = words[n] + ' ';
            }
            else {
                line = testLine;
            }
        }

        result += line;

        return result;
    }

};

GE.String = {

    /**
     * Function count the occurrences of substring in a string;
     *
     * @param {String} string   Required. The string;
     * @param {String} subString    Required. The string to search for;
     * @param {Boolean} [allowOverlapping=false]    Optional. Default: false;
     */
    count: function(string, subString, allowOverlapping){

        string+=""; subString+="";
        if(subString.length<=0) return string.length+1;

        var n=0, pos=0;
        var step=(allowOverlapping)?(1):(subString.length);

        while(true){
            pos=string.indexOf(subString,pos);
            if(pos>=0){ n++; pos+=step; } else break;
        }
        return(n);
    }

};

GE.IIdentificable = GE.Interface({
    $name: "IIdentificable",

    getId: function() {},

    /**
     * Type-independent ID.
     */
    getUId: function() {}
});

/**
 * Event.
 *
 * @type {Event}
 */
GE.Event = GE.Klass({
    $name: "Event",

    __objects: {},
    __subscriptions: {},

    initialize: function() {

    },

    add: function(id, obj, fn) {
        this.__objects[id] = obj;
        if(typeof this.__subscriptions[id] === 'undefined') {
            this.__subscriptions[id] = [];
        }

        this.__subscriptions[id].push(fn);
    },

    remove: function(id) {
        delete this.__objects[id];
        delete this.__subscriptions[id];
    },

    run: function(args) {
        var rmv = [];
        var $this = this;

        GE.jQuery.each(this.__subscriptions, function(id, fns) {
            var obj = $this.__objects[id];

            if(obj) {

                for(var i = 0; i < fns.length; i++) {
                    fns[i].call(obj, args);
                }

            }
            else {
                rmv.push(id);
            }

        });

        for(var i = 0; i < rmv.length; i++) {
            this.remove(rmv[i]);
        }
    }

});

/**
 * Events manager.
 *
 * @type {EventManager}
 */
GE.EventManager = GE.Klass({

    events: {},

    haveTrigger: function(ev) {
        return typeof this.events[ev] !== 'undefined';
    },

    /**
     * on(id, object, event name, callback)
     * on(object, event name, callback)
     * this.on(event name, callback)
     *
     * @param {string|Entity|Scene} id
     * @param {function|Entity} obj
     * @param {string|function} [ev]
     * @param {function} [fn]
     * @returns {*}
     */
    on: function(id, obj, ev, fn){

        //  this.on(a, b)
        if(typeof obj === 'function' && !ev && !fn) {


            fn = obj;
            ev = id;
            id = this.__parseId(this);
            obj = this;

        }
        //  on(a, b, c)
        else if(typeof id !== 'string') {

            fn = ev;
            ev = obj;
            obj = id;

            id = this.__parseId(id);

        }

        if(!this.haveTrigger(ev)) {
            this.events[ev] = new GE.Event();
        }

        this.events[ev].add(id, obj, fn);

        return this;
    },

    /**
     * off(id, ev)
     * off(id, "all")
     * off("all", ev)
     * off(ev)
     *
     * @param id
     * @param ev
     * @returns {*}
     */
    off: function(id, ev) {
        //
        //  Opt 4: Delete the specified event from the object "_".
        //

        if(typeof ev === 'undefined') {
            ev = id;
            id = "_";
        }

        id = this.__parseId(id);

        //
        //  Opt 2: Delete all object's events
        //

        if(ev == 'all') {

            throw "Not implemented.";

            //return this;
        }

        //
        //  Opt 3: Delete all events from an object
        //

        if(id == 'all') {

            var $this = this;
            GE.jQuery.each(this.events, function(k, v) {
                $this.off(id, k);
            });

            return this;
        }

        //
        //  Opt 1: Delete an event from an object
        //

        var e = this.events[ev];

        if(e) {
            e.remove(id);
        }
        else {
            throw "Unknown event: "+ev;
        }

        return this;
    },

    trigger: function(ev, args) {
        var e = this.events[ev];
        if(e) {
            e.run(args);
        }

        return this;
    },

    __parseId: function(id) {
        if(typeof id !== 'string') {
            if(GE.is(id, GE.IIdentificable)) {
                id = id.getUId();
            }
            /*else if(id instanceof GE.Scene) {
                id = id.name || id.$name; // TODO: warning
            }*/
            else {
                id = "_";
                console.warn("Unknown type for ID");
            }
        }

        return id;
    }
});

GE.Events = {
    Engine: {
        READY: "gengine-ready",
        START: "gengine-start",
        STOP: "gengine-stop",
        PREUPDATE: "gengine-preupdt",
        UPDATE: "gengine-update",
        POSUPDATE: "gengine-postupdt",
        REDRAW: "gengine-redraw"
    },

    Scene: {
        START: "scn-start",
        CHANGE: "scn-change"
    },

    Entity: {
        CREATE: "entity-create",
        DESTROY: "entity-destroy"
    },

    Resource: {
        LOAD_FAIL: "res-fail",
        LOAD_SUCCESS: "res-success",
        LOAD_FINISH: "res-finish"
    },

    Generic: {
        DISPOSE: "ev-dispose"
    },

    Com: {

    }
};

/**
 * Game Engine.
 * @type {Engine}
 * @constructor
 */
GE.Engine = GE.Klass(GE.EventManager, {

    //  *****************************
    //  Class definitions
    //  *****************************

    $name: "Engine",

    $locked: false,

    $statics: {
        idCounter: 0,

        incrementId: function() {
            return ++GE.Engine.$static.idCounter;
        }
    },


    //  *****************************
    //  Attributes
    //  *****************************

    /**
     * Current scene (ID).
     */
    currentScene: null,

    /**
     * Next scene (ID).
     */
    changeScene: null,

    /**
     * Scenes.
     */
    scenes: {},

    /**
     * Modules.
     */
    modules: {},

    /**
     * Input manager.
     */
    input: null,


    //  *****************************
    //  Ctor
    //  *****************************

    initialize: function() {
        GE.engine = this;
        this.input = new GE.InputManager();
    },


    //  *****************************
    //  Engine Methods
    //  *****************************

    /**
     * TODO: Implement a better load for async modules.
     *
     * @param defaultScene
     * @param [debug]
     * @returns {Engine}
     */
    start: function(defaultScene, callback) {


        if(GE.Debug)
            console.log("DEBUG MODE ON");

        this.input.detectDevices();

        this.changeScene = defaultScene;

        var asyncs = 0;

        var call = function(e) {
            if(GE.Debug)
                console.log("Loaded '"+e+"'");
            if(-- asyncs == 0 && callback) {
                if(GE.Debug)
                    console.log("Async load finished");
                callback();
            }
        };

        var load = function(mod, name) {
            try {
                if(mod.async) {
                    asyncs ++;
                    try {
                        mod.load(call, call);
                    }
                    catch(e) {
                        asyncs --;
                        throw e;
                    }
                }
                else {
                    mod.load();
                    if(GE.Debug)
                        console.log('Loaded "'+mod.name+'"');
                }
            }
            catch(e) {
                console.error(
                    'Error loading module "'+name+'".'+ ( GE.Debug ? (" "+e):"" )
                );
            }
        };

        GE.jQuery.each(this.modules, function(k, v) {
            if(GE.Debug) {
                console.log('Loading module "'+k+'"...');
            }
            load(v);
        });

        return this;
    },

    update: function(args) {

        if(this.currentScene != this.changeScene) {

            var persistentEntities = this.currentScene ? this.getCurrentScene().change(this.changeScene, args) : {};
            var nextScene = this.getScene(this.changeScene);

            if(nextScene == null) {
                var scene = this.changeScene;
                this.changeScene = this.currentScene;
                throw "Error, scene "+scene+" not found";
            }

            nextScene.start(persistentEntities);

            this.currentScene = this.changeScene;
        }


        //
        //  Create+delete objects
        //

        //this.getCurrentScene().update();

        //
        //  Update objects
        //

        this.trigger(GE.Events.Engine.PREUPDATE, args);
        this.trigger(GE.Events.Engine.UPDATE, args);
        this.trigger(GE.Events.Engine.POSUPDATE, args);

    },

    stop: function() {

        return this;

    },


    //  *****************************
    //  Public Methods
    //  *****************************

    addModule: function(mod) {
        this.modules[mod.name] = mod;
        return this;
    },

	/**
	 * Adds a single scene or an array of scenes into the engine.
	 */
    setScenes: function(scenes) {
		if(GE.jQuery.isArray(scenes)) {
			for(var i = 0; i < scenes.length; i++) {
				var sc = scenes[i];
				this.scenes[sc.name] = sc;
			}
		}
		else {
			this.scenes = GE.jQuery.extend({}, this.scenes, scenes);
		}

        return this;
    },

    /**
     * Gets a specific scene.
     * @param sceneId
     * @returns {*}
     */
    getScene: function(sceneId) {
        return this.scenes[sceneId];
    },

    /**
     * Gets the current scene.
     * @returns {*}
     */
    getCurrentScene: function() {
        return this.getScene(this.currentScene);
    }
});

GE.Color = GE.Klass({

    $name: "Color",

    $statics: {
        red: function() {
            return new GE.Color().rgb(255, 0, 0);
        },

        green: function() {
            return new GE.Color().rgb(0, 255, 0);
        },

        blue: function() {
            return new GE.Color().rgb(0, 0, 255);
        },

        white: function() {
            return new GE.Color().rgb(255, 255, 255);
        },

        black: function() {
            return new GE.Color();
        }
    },

    r: 0,
    g: 0,
    b: 0,
    a: 1.0,

    initialize: function() {

    },

    rgba: function(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.a = a;
        this.b = b;
        return this;
    },

    rgb: function(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
    },

    ts: function() {
        return this.toString();
    },

    toString: function() {
        return "rgba(" + this.r + "," + this.g + "," + this.b + "," + this.a + ")";
    }
});

/**
 * Object component.
 *
 * Events:
 *
 * @class Component
 * @constructor
 *
 */
GE.Component = GE.Abstract(GE.EventManager, {

    //  *****************************
    //  Class Definitions
    //  *****************************

    $name: "Component",

    $implements: [GE.IIdentificable],

    $statics: {
        componentId: 1
    },

    $abstract: {
        /**
         * TODO DOC
         *
         * @method load
         */
        load: function () {},

        /**
         * TODO DOC
         *
         * @method dispose
         */
        dispose: function () {}
    },

    //  *****************************
    //  Attributes
    //  *****************************

    /**
     * Id.
     */
    __id: 0,

    /**
     * Component's instance name.
     */
    __name: null,

    /**
     * Attached to entity.
     */
    entity: null,


    //  *****************************
    //  Constructor
    //  *****************************

    /**
     * TODO DOC
     *
     * @param {string} [name=''] Instance name.
     * @method initialize
     */
    initialize: function (name) {
        this.$super();
        this.__id = GE.Component.$static.componentId++;
        this.__name = name || "";
    },


    //  *****************************
    //  Public Methods
    //  *****************************

    /**
     * Unique component in instance?
     *
     * @returns {boolean} Result. Default: false.
     */
    isUnique: function() {
        return false;
    },

    /**
     * TODO DOC
     *
     * @returns {string}
     */
    getName: function() {
        return this.__name;
    },

    /**
     * TODO DOC
     *
     * @param {string} value Name
     * @returns {*}
     */
    setName: function(value) {
        this.__name = value;
        return this;
    },

    /**
     * TODO DOC
     *
     * @returns {number}
     */
    getId: function() {
        return this.__id;
    },

    /**
     * Type-independent ID.
     */
    getUId: function() {
        return "$com("+this.$name+")"+String(this.__id);
    },

    /**
     * TODO DOC
     *
     * @returns {string}
     */
    toString: function() {
        return this.getUId();
    }
});

/**
 * @author alteredq / http://alteredqualia.com/
 */

GE.Clock = function ( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

};

GE.Clock.prototype = {

	constructor: GE.Clock,

	start: function () {

		this.startTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

		this.oldTime = this.startTime;
		this.running = true;
	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = self.performance !== undefined && self.performance.now !== undefined
					? self.performance.now()
					: Date.now();

			diff = 0.001 * ( newTime - this.oldTime );
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

/**
 * Game Entity.
 *
 * @type {Entity}
 */
GE.Entity = GE.Klass(GE.EventManager, {

    //  *****************************
    //  Class Definitions
    //  *****************************

    $name: "Entity",

    $type: "entity",

    $implements: [GE.IIdentificable],

    $locked: false,

    //  *****************************
    //  Attributes
    //  *****************************

    /**
     * Instance id.
     */
    __id: 0,

    /**
     * Persistent.
     */
    persistent: false,

    /**
     * Current scene (instance).
     */
    scene: null,

    /**
     * Friendly name.
     */
    name: "",

    /**
     * Components.
     */
    components: {},

    //  *****************************
    //  Engine events (only for
    //      generics game entities)
    //  *****************************

    onCreate: function(){},
    onDelete: function(){},


    //  *****************************
    //  Constructor
    //  *****************************

    initialize: function() {
        //  DO NOT OVERRIDE, USE READY

        this.__id = GE.engine.$static.incrementId();
    },


    //  *****************************
    //  Methods
    //  *****************************

    ready: function() {

    },

    /**
     * TODO DOC
     *
     * @method addComponent
     */
    addComponent: function (component) {
        var id = component.getId();

        if (this.getComponent(id) == null) {

            this.components[id] = component;

            component.entity = this;
            component.load();

        }

        return this;
    },

    /**
     * TODO DOC
     *
     * @param {string|number} arg  Name or ID
     * @method getComponent
     */
    getComponent: function (arg) {
        if(typeof arg === 'number') {
            return this.components[arg];
        }
        else if(typeof arg === 'string') {

            var result = null;
            var name = arg.toLowerCase();

            this.eachComponent(function(comp) {
                if(result === null) {
                    if(comp.getName().toLowerCase() == name) {
                        result = comp;
                    }
                }
            });

            return result;
        }
        else {
            throw "The param must be a string or number.";
        }

    },

    /**
     * TODO DOC
     *
     * @param {string|number} arg  Name or ID
     * @method getComponents
     */
    getComponents: function (arg) {
        if(typeof arg === 'number') {
            return [this.components[arg]];
        }
        else if(typeof arg === 'string') {

            var result = [];
            var name = arg.toLowerCase();

            this.eachComponent(function(comp) {
                if(comp.getName().toLowerCase() == name) {
                    result.push(comp);
                }
            });

            return result;
        }
        else {
            throw "The param must be a string or number.";
        }
    },

    /**
     * TODO DOC
     *
     * @param {string} arg  Type
     * @method getComponents
     */
    getComponentsFromType: function (arg) {
        if(typeof arg === 'string' && arg) {

            var result = [];
            var type = arg.toLowerCase();

            this.eachComponent(function(comp) {
                if(comp.$name.toLowerCase() == type) {
                    result.push(comp);
                }
            });

            return result;
        }
        else {
            throw "The param must be a string.";
        }
    },

    /**
     * TODO DOC
     *
     * @method hasComponents
     */
    hasComponents: function() {
        return Object.keys(this.components).length>0;
    },

    /**
     * TODO DOC
     *
     * @method eachComponent
     */
    eachComponent: function(funct) {
        for(var key in this.components)
        {
            if (this.components.hasOwnProperty(key))
            {
                funct(this.components[key]);
            }
        }
        return this;
    },

    /**
     * Free all object's resource after delete.
     */
    dispose: function() {

        //  Release components

        this.eachComponent(function(comp) {
            if(comp) {
                comp.dispose();
            }
        });

        delete this.components;

        //  Dispose event

        this.trigger(GE.Events.Generic.DISPOSE);
    },

    /**
     * Removes the object. IDEM to Scene.removeObject.
     */
    destroy: function() {
        this.scene.removeObject(this);
    },

    /**
     * Gets the ID.
     * @returns {number}
     */
    getId: function() {
        return this.__id;
    },

    /**
     * Type-independent ID.
     */
    getUId: function() {
        return "$entity("+this.$name+")"+String(this.__id);
    }
});

/**
 * Game Engine Module.
 *
 * Events:
 *
 * @class Module
 * @constructor
 *
 */
GE.Module = GE.Abstract({

    //  *****************************
    //  Class definitions
    //  *****************************

    $name: "Module",

    $abstract: {
        /**
         * TODO DOC
         *
         * @param [success]
         * @param [fail]
         * @method load
         */
        load: function (success, fail) {},

        /**
         * TODO DOC
         *
         * @method dispose
         */
        dispose: function () {}
    },

    //  *****************************
    //  Attributes
    //  *****************************

    name: "",

    /**
     * Load needs callback?
     */
    async: false
});

GE.ResourceStatus = {
    NONE: 0,
    SUCCESS: 1,
    FAIL: -1
};

/**
 * Abstract game resource.
 * @type {Resource}
 * @constructor
 */
GE.Resource = GE.Abstract(GE.EventManager, {

    //  *****************************
    //  Class Definitions
    //  *****************************

    $name: "Resource",

    $abstracts: {

        /**
         * Starts the load. Override if you want to make children resources.
         */
        load: function(args){}

    },

    //  *****************************
    //  Attributes
    //  *****************************

    /**
     * Resource name (Identifier).
     */
    name: "",

    /**
     * Resource type. Example: sprite, model, sound, etc.
     */
    type: "generic",

    /**
     * Is resource loaded?
     */
    loaded: false,

    /**
     * Resource status.
     */
    status: GE.ResourceStatus.NONE,

    /**
     * Resource.
     */
    _resource: null,


    //  *****************************
    //  Constructor
    //  *****************************


    /**
     * Constructor.
     *
     * @param [opts] Options.
     * @param {string} [opts.name] Name.
     * @param {string} [opts.type] Resource type.
     */
    initialize: function(opts) {
        this.type = opts.type || this.type;
        this.name = opts.name || '';

        if(!this.name || this.name == '')
            throw 'A resource must have a unique name.'
    },


    //  *****************************
    //  Methods
    //  *****************************

    /**
     * Gets the resource loaded. Virtual function.
     */
    getRes: function() {
        return this._resource;
    },

    /**
     * Assign the value from the loaded resource and trigger success events.
     *
     * @param res Loaded resource.
     */
    success: function(res) {
        this._resource = res;
        this.loaded = true;
        this.status = GE.ResourceStatus.SUCCESS;

        this.trigger(GE.Events.Resource.LOAD_SUCCESS, this);
        this.trigger(GE.Events.Resource.LOAD_FINISH, {success: true, resource: this, result: res});

        return this;
    },

    /**
     * Trigger error events.
     *
     * @param message Error message or object.
     */
    fail: function(message) {
        this._resource = null;
        this.loaded = true;
        this.status = GE.ResourceStatus.FAIL;

        console.warn(message);

        this.trigger(GE.Events.Resource.LOAD_FAIL, this);
        this.trigger(GE.Events.Resource.LOAD_FINISH, {success: false, result: message, resource: this});

        return this;

    },

    /**
     * Releases the resource.
     */
    dispose: function() {
        this._resource = null;
        this.loaded = false;
    }

});

/**
 * Resource Container.
 * @type {ResourceContainer}
 * @constructor
 */
GE.ResourceContainer = GE.Klass({

    $name: "ResourceContainer",

    $statics: {
        globalRes: {}
    },

    resources: {},

    /**
     * Adds a local/global resource.
     *
     * @param {Resource} resource
     * @param {bool} [global]
     */
    add: function(resource, global) {

        var list;

        if(global) {
            list = GE.ResourceContainer.$static.globalRes;
        }
        else {
            list = this.resources;
        }

        list[resource.name] = resource;
    },

    /**
     * Gets a local resource.
     * @param name
     * @param [global]
     * @returns {*}
     */
    get: function(name, global) {
        if(global) {
            return GE.ResourceContainer.$static.globalRes[name];
        }
        return this.resources[name];
    },

    /**
     * Load the resources.
     *
     * @param [args]
     */
    load: function(args) {

        args = args || {};

        GE.jQuery.each(this.resources, function(k, r) {
            if(!r.loaded) {
                r.load(args[k]);
            }
        });

        return this;
    },

    /**
     * Disposes an specific resource.
     *
     * @param {string} name
     * @param [global]
     */
    release: function(name, global) {

        var list;

        if(global) {
            list = GE.ResourceContainer.$static.globalRes;
        }
        else {
            list = this.resources;
        }

        if(list[name]) {
            list[name].dispose();
            delete list[name];
        }

        return this;
    },

    /**
     * Releases all resources.
     *
     * Class reusable.
     *
     * @param [globals] Include globals?
     */
    dispose: function(globals) {

        GE.jQuery.each(this.resources, function(k, v) {
            v.dispose();
        });

        if(globals) {

            GE.jQuery.each(GE.ResourceContainer.$static.globalRes, function(k, v) {
                v.dispose();
            });

            GE.ResourceContainer.$static.globalRes = {};
        }

        this.resources = {};
    }

});

/**
 * Resource load queue.
 * @type {ResourceQueue}
 * @constructor
 */
GE.ResourceQueue = GE.Klass(GE.EventManager, {

    $name: "ResourceQueue",

    resources: [],

    current: 0,

    /**
     * Adds a local/global resource.
     *
     * @param {Resource} resource
     * @param {bool} [global]
     */
    add: function(resource, global) {

        this.resources.push(resource);

        var name = resource.name;
        resource.on("_loader_", this, GE.Events.Resource.LOAD_FINISH, function(args) {
            if(args.success) {
                //
            }
            else {
                console.warn(args.result);
            }

            this.report(name);
        });

    },

    start: function() {
        this.current = 0;
        this.loadCurrent();

    },

    report: function(name) {
        this.current ++;
        if(this.current < this.resources.length) {
            this.loadCurrent();
        }
    },

    loadCurrent: function() {
        this.resources[this.current].load();
    },

    getProgress: function() {
        if(this.resources.length == 0)
            return 0;

        return this.current / this.resources.length;
    }

});

/**
 * Game Scene.
 * @constructor
 */
GE.Scene = GE.Klass(GE.EventManager, {

    //  *****************************
    //  Class definitions
    //  *****************************

    $name: "Scene",

    $implements: [GE.IIdentificable],

    //  *****************************
    //  Attributes
    //  *****************************

    /**
     * Scene name. This identifies the scene.
     */
    name: "",

    /**
     * Resources container.
     */
    resources: null,

    /**
     * Objects identified by ID.
     */
    objects: {},

    /**
     * Objects identified by name.
     */
    objectsByName: {},

    /**
     * Objects creation queue.
     */
    objectsToCreate: [],

    /**
     * Objects destruction queue.
     */
    objectsToDelete: [],

    //  *****************************
    //  Ctor
    //  *****************************

    initialize: function() {
        this.resources = new GE.ResourceContainer();
    },


    //  *****************************
    //  Public Methods
    //  *****************************

    start: function(persistents) {

        if(persistents) {
            GE.jQuery.each(persistents, function(i, entity) {
                this.__addObject(entity);
            });
        }

		this.trigger(GE.Events.Scene.START);
        GE.engine.trigger(GE.Events.Scene.START);
        GE.engine.on(this, GE.Events.Engine.PREUPDATE, this.update);
    },

    update: function() {


        //
        //  Create objects
        //

        if (this.objectsToCreate.length > 0) {

            var executeCreateEvent = [];
            for (var i = 0; i < this.objectsToCreate.length; i++) {
                var object = this.objectsToCreate[i];
                if(object) {
                    //  this.__addObject(object); // Mv1

                    object.ready();
                    if (object.haveTrigger(GE.Events.Entity.CREATE)) {
                        executeCreateEvent.push(object);
                    }
                }
            }
            this.objectsToCreate = [];

            for (var i = 0; i < executeCreateEvent.length; i++) {
                executeCreateEvent[i].trigger(GE.Events.Entity.CREATE);
            }

        }

        //
        //  Destroy objects
        //

        if (this.objectsToDelete.length > 0) {
            for (var i = 0; i < this.objectsToDelete.length; i++) {
                var id = this.objectsToDelete[i]; // Because is an ids list
                this.__deleteObject(id);
            }

            this.objectsToDelete = [];
        }
    },

    /**
     * Change the scene to another.
     *
     * @param {Scene} nextScene Next scene.
     * @param {Array} args Extra options.
     * @returns {Entity[]} Persistent entities.
     */
    change: function(nextScene, args) {

        //
        //  Events
        //

        GE.engine.trigger(GE.Events.Scene.CHANGE, GE.jQuery.extend({}, args || {}, { current: this, next: nextScene }));
        GE.engine.off(this, GE.Events.Engine.PREUPDATE);

        //
        //  Add non-persistents to delete queue
        //

        var deleteObjects = this.findObjectsIf(function(obj) {
            return !obj.persistent;
        });

        for (var i = 0; i < deleteObjects.length; i++) {
            this.__deleteObject(deleteObjects[i], true);
        }

        //
        //  Release resources
        //

        var resources = this.resources;

        setTimeout(function() {
            resources.dispose();
        }, 10);

        //
        //  Return persistents
        //

        return this.findObjectsIf(function(obj) {
            return obj.persistent;
        });
    },

    /**
     *	Adds a new Entity to the game.
     *
     * 	@param {Entity} object Entity instance.
     * 	@method addObject
     * 	@return {int} Instance ID.
     **/
    addObject: function(object) {
        if(object.onCreate)
            object.onCreate();
        this.__addObject(object);   //  Line Moved from Mv1 to here
        this.objectsToCreate.push(object);
        return object.getId();
    },

    /**
     * 	Adds a array of Entities to the game.
     *
     * 	@param	{Array} _objects Entity array.
     * 	@method addObjects
     * 	@return {int[]} IDS from instances.
     **/
    addObjects: function(_objects) {
        var ids = [];
        for(var i = 0; i < _objects.length; i++) {
            ids[i] = this.addObject(_objects[i]);
        }
        return ids;
    },

    /**
     * 	Iterate over all Entities, executing the function "funct" for each element.
     *
     * 	@param	{function} funct Function to execute.
     * 	@method eachObject
     **/
    eachObject: function(funct) {
        for (var id in this.objects) {
            var obj = this.objects[id];
            funct(obj);
        }
    },

    /**
     * 	Removes the instance with specified ID.
     *
     * 	@param	{int|Entity} id Instance ID or Entity.
     * 	@method removeObject
     **/
    removeObject: function (id) {
        if(!id)
            return;

        if (GE.isEntity(id)) {
            id = id.getId();
        }

        if (this.objectsToDelete.indexOf(id) < 0)
            this.objectsToDelete.push(id);
    },

    /**
     * 	Removes all instances with specified name.
     *
     * 	@param	{string} name Object name.
     * 	@method removeObjects
     **/
    removeObjects: function (name) {
        var objects = this.findObjects(name);
        for (var i = 0; i < objects.length; i++) {
            var id = objects[i].__id;
            this.removeObject(id);
        }
    },

    /**
     * 	Removes all instances using a function condition.
     *
     * 	@param {function} query Conditional function. function(object) { return true || false;}
     * 	@method removeObjects
     **/
    removeObjectsIf: function (query) {
        var objects = this.findObjectsIf(query);
        for (var i = 0; i < objects.length; i++) {
            this.removeObject(objects[i]);
        }
    },

    /**
     * Gets the instance with specified ID.
     *
     * @param {int} id Instance ID.
     * @method getObject
     * @return {Entity} Instance.
     **/
    getObject: function(id) {
        return this.objects[id];
    },

    /**
     * Gets all instances with specified name.
     *
     * @param {string} name Object name.
     * @method findObjects
     * @return {Entity[]} Instances.
     **/
    findObjects: function(name) {
        var result = this.objectsByName[name];
        if(result == undefined)
            return [];
        else
            return result;
    },

    /**
     * Gets all instances with specified type.
     *
     * @param {Object|string} typeOrTypeName Object name.
     * @method findObjectsByType
     * @return {Entity[]} Instances.
     **/
    findObjectsByType: function(typeOrTypeName) {
        if(typeof typeOrTypeName === 'string') {
            typeOrTypeName = typeOrTypeName.toLowerCase();
            return this.findObjectsIf(function(o) {
                return o.$type.toLowerCase() == typeName;
            });
        }
        else {
            return this.findObjectsIf(function(o) {
                return dejavu.instanceOf(o, typeOrTypeName);
            });
        }
    },

    /**
     * Gets all instances using a function condition.
     *
     * @param {function} query Conditional function. function(object) { return true || false;}
     * @method findObjects
     * @return {Entity[]} Instances.
     **/
    findObjectsIf: function(query) {
        var result = [];
        for (var id in this.objects) {
            var o = this.objects[id];
            if(query(o)) {
                result.push(o);
            }
        }
        return result;
    },

    /**
     * Gets the first instance with specified name.
     *
     * @param {string} name Object name.
     * @method findObject
     * @return {Entity} Instance.
     **/
    findObject: function(name) {
        var result = this.objectsByName[name];
        if(typeof result === 'undefined')
            return result;
        else
            return result[0];
    },


    //  *****************************
    //  Private Methods
    //  *****************************

    /**
     * Adds the object.
     *
     * @param object
     * @private
     */
    __addObject: function(object) {
        if (object) {
            // Lists
            this.objects[object.getId()] = object;
            var objByName = this.objectsByName[object.name];
            if (this.objectsByName[object.name] == undefined) {
                this.objectsByName[object.name] = [object];
            }
            else {
                this.objectsByName[object.name].push(object);
            }


            object.scene = this;
        }
    },

    /**
     * Deletes the object.
     *
     * @param id Entity or ID.
     * @param {boolean} [cancelDeleteEvent=false] Cancel entity's destroy event call.
     * @private
     */
    __deleteObject: function(id, cancelDeleteEvent) {
        var object = GE.isEntity(id) ? id : this.objects[id];

        if (object) {
            if (!cancelDeleteEvent)
                object.trigger(GE.Events.Entity.DESTROY);

            var list = this.objectsByName[object.name];
            if(list) {
                var j = 0;
                while (j < list.length && list[j].__id != id) {
                    j++;
                }
                if (j < list.length) {
                    list.splice(j, 1);
                }
            }

            object.onDelete();
            object.dispose();
            delete this.objects[id];
            delete object;
        }
    } ,

    //  *****************************
    //  IIdentificable implementation
    //  *****************************

    /**
     * Gets the ID.
     * @returns {number}
     */
    getId: function() {
        return this.name;
    },

    /**
     * Type-independent ID.
     */
    getUId: function() {
        return "$scene("+this.$name+")"+this.name;
    }
});

GE.Path = {

    combine: function(){
        var result = "",
            c = "/",
            a;

        for (var i = 0; i < arguments.length; ++i){

            a = String(arguments[i]);

            result += a;

            if(a.indexOf(c) != a.length-1 && i < arguments.length - 1) {
                result += c;
            }

        }

        if(result.indexOf(c) == result.length-1) {
            result = result.substr(0, result.length-1);
        }

        return result;
    }

};

/**
 * Abstract input.
 * @type {Input}
 * @constructor
 */
GE.Input = GE.Abstract(GE.EventManager, {

    $name: "Input",

    name: "",

    initialize: function() {

    }

});

GE.InputActionType = {
    UNDEFINED: -1,
    BUTTON: 0,
    AXIS: 1
};

GE.InputAction = GE.Klass({

    name: "",

    actionType: GE.InputActionType.UNDEFINED,

    actionKey: null

});

GE.DeviceStatus = {
    NONE: 0,
    PLUGGED: 1,
    CONNECTED: 1,
    UNPLUGGED: 2,
    DISCONNECTED: 2
};

GE.DeviceAxis = GE.Klass({

    value: {dx: 0, dy: 0},
    deadZone: 0.001,

    initialize: function() {

    },

    set: function(dx, dy) {
        if(this.deadZone != 0) {
            //  TODO
            /*if(dx <= this.deadZone) {
                dx = 0;
            }
            if(dy <= this.deadZone) {
                dy = 0;
            }
            if(dx >= 1-this.deadZone) {
                dx = 1;
            }
            if(dy >= 1-this.deadZone) {
                dy = 1;
            } */

        }

        this.value.dx = dx;
        this.value.dy = dy;
    },

    clear: function() {
        this.set(0, 0);
    },

    get: function(){
        return this.value;
    },

    getX: function(){
        return this.value.dx;
    },

    getY: function(){
        return this.value.dy;
    },

    /**
     * TODO
     * @returns {boolean}
     */
    haveButton: function() {
        return false;
    }
});

/**
 * Abstract input device.
 * @type {InputDevice}
 * @constructor
 */
GE.InputDevice = GE.Abstract(GE.EventManager, {

    $name: "InputDevice",

    $statics: {
        inputDeviceId: 0
    },

    $abstracts: {
        isPressed: function(key) {},
        isReleased: function(key) {},
        isUp: function(key) {},
        isDown: function(key) {}
    },

    __id: 0,

    _status: 0,

    __axis: [],

    initialize: function() {
        this.__id = ++GE.InputDevice.$static.inputDeviceId;
        this._status = GE.DeviceStatus.NONE;
    },

    start: function() {
        return this;
    },

    stop: function() {
        return this;
    },

    dispose: function() {
        this.stop();
    },

    countAxis: function() {
        return this.__axis.length;
    },

    getAxis: function(axis) {
        if(typeof axis === 'undefined')
            axis = 0;

        return this.__axis[axis];
    },

    getStatus: function() {
        return this._status;
    },

    _addAxis: function() {
        this.__axis.push(new GE.DeviceAxis());
    },

    getId: function() {
        return "$device("+this.$name+"_"+this.__id+")";
    },

    getUId: function() {
        return "$device("+this.$name+"_"+this.__id+")";
    }

});

/**
 * Input device mapping table.
 * ONLY Internal use.
 */
GE.InputDeviceMap = GE.Klass({

    _map: {},

    _device: null,

    initialize: function(device) {
        this._device = device;
    },

    add: function(name, action) {

        var m = this._map;
        if(!m[name]) {
            m[name] = [];
        }

        m[name].push(action);
    },

    getKeys: function(name) {
        return this._map[name];
    },

    getDevice: function() {
        return this._device;
    }

});


/**
 * Input manager.
 * @type {InputManager}
 * @constructor
 */
GE.InputManager = GE.Klass(GE.EventManager, {

    //  *****************************
    //  Class Definitions
    //  *****************************

    devices: {},

    maps: {
        "default": null
    },


    //  *****************************
    //  Constructor
    //  *****************************

    initialize: function() {
        this.maps["default"] = new GE.InputMap();
    },


    //  *****************************
    //  Public Methods
    //  *****************************

    getMap: function(name) {
        if(typeof name === 'undefined')
            return this.maps["default"];

        return this.maps[name];
    },

    detectDevices: function() {
        var i = 0;
        if(GE.MouseDevice && !this.devices["mouse"]) {
            this.devices["mouse"] = new GE.MouseDevice().start();
            console.log(this.devices["mouse"].getId() + " loaded.");
            ++i;
        }
        if(GE.KeyboardDevice && !this.devices["keyboard"]) {
            this.devices["keyboard"] = new GE.KeyboardDevice().start();
            console.log(this.devices["keyboard"].getId() + " loaded.");
            ++i;
        }

        return i;
    },

    getPlayerDevice: function(playerNum) {
        if(typeof playerNum === 'undefined' || playerNum <= 1) {
            throw "Not implemented."
        }
        else {
            throw "Not implemented."
        }
    }

});

/**
 * Input mapping table.
 */
GE.InputMap = GE.Klass({

    name: "",

    _deviceMap: {},

    initialize: function(name) {
        this.name = name || "";
    },

    add: function(device, name, action) {

        var d = device,
            m = this._deviceMap[d.getUId()];

        if(!m) {
            m = new GE.InputDeviceMap(d);
            this._deviceMap[d.getUId()] = m;
        }

        m.add(name, action);
    },

    isDown: function(name, deviceId) {
        return this.__test(name, "isDown", deviceId);
    },

    isUp: function(name, deviceId) {
        return this.__test(name, "isUp", deviceId);
    },

    isPressed: function(name, deviceId) {
        return this.__test(name, "isPressed", deviceId);
    },

    isReleased: function(name, deviceId) {
        return this.__test(name, "isReleased", deviceId);
    },

    check: function(names, deviceId) {
        var dvs = (typeof deviceId === 'undefined') ? { deviceId: this._deviceMap } : this._deviceMap[deviceId],
            device,
            keys;

        if(typeof names === 'string') {
            names = [names];
        }

        GE.jQuery.each(dvs, function(k, v) {
            var name;

            for(var i = 0; i < names.length; i++) {
                name = names[i];
                keys = v.getKeys(name);

                if(keys) {
                    return false;
                }
            }

            return true;
        });

        return false;
    },

    /**
     *
     * @param name
     * @param fn
     * @param [deviceId]
     */
    __test: function(name, fn, deviceId) {

        var dvs = (typeof deviceId === 'undefined') ? { deviceId: this._deviceMap } : this._deviceMap[deviceId],
            device,
            keys;

        GE.jQuery.each(dvs, function(k, v) {
            keys = v.getKeys(name);
            device = v.getDevice();

            for(var i = 0; i < keys.length; i++) {
                if(device[fn](keys[i]))
                {
                    return true;
                }
            }
        });

        return false;

    }
});

GE.InputTypes = {
    KEYBOARD:   1,
    TOUCH:      2,
    JOYSTICK:   4,
    MOUSE:      8,
    KINECT:     16
};

GE.InputButtons = {
    START: 1,
    CANCEL: 2,
    FIRE: 3,
    FIRE2: 4
};


//  TODO: TEST

var KEY_UP = 0;
var KEY_PRESSED = 1;
var KEY_DOWN = 2;
var KEY_RELEASED = 3;

GE.KeyboardDefaults = {

};

GE.KeyboardDevice = GE.Klass(GE.InputDevice, {

    //  *****************************
    //  Class definitions
    //  *****************************

    $name: "KeyboardDevice",

    //  *****************************
    //  Attributes
    //  *****************************

    names: 0,
    codes: 0,

    __keys: [],
    __newKeys: {},

    __listeners: {},

    //  *****************************
    //  Ctor
    //  *****************************

    initialize: function() {
        this.$super();

        GE.engine.keyboard = this;

        this._status = GE.DeviceStatus.CONNECTED;
    },

    //  *****************************
    //  Overrides
    //  *****************************

    start: function() {
        this.$super();

        this.__createEvents();
        this.__attachEvents();
        this.__loadCodes();
        this._addAxis();

        GE.engine.on(this.getUId(), this, GE.Events.Engine.POSUPDATE, function() {

            for (var i = 0; i < this.__keys.length; i++) {
                if (this.__newKeys[i] == undefined) {
                    switch (this.__keys[i]) {
                        case KEY_PRESSED:
                        {
                            this.__keys[i] = KEY_DOWN;
                        } break;
                        case KEY_RELEASED:
                        {
                            this.__keys[i] = KEY_UP;
                        } break;
                    }
                }
            }
            this.__newKeys = {};

        }.$member().bind(this));

        return this;
    },

    stop: function() {
        this.$super();
        this.__detachEvents();
        return this;
    },

    //  *****************************
    //  Public methods
    //  *****************************

    keycode: function (searchInput) {
        if ('number' === typeof searchInput) return this.names[searchInput];
        var search = String(searchInput);
        var foundNamedKey = this.codes[search.toLowerCase()];
        if (foundNamedKey) return foundNamedKey;
        if (search.length === 1) return search.charCodeAt(0);
        return undefined;
    },

    isPressed: function (key) {
        return this.__keys[this.keycode(key)] == KEY_PRESSED;
    },

    isReleased: function(key) {
        return this.__keys[this.keycode(key)] == KEY_RELEASED;
    },

    isDown: function(key) {
        return this.__keys[this.keycode(key)] == KEY_DOWN;
    },

    isUp: function(key) {
        return this.__keys[this.keycode(key)] == KEY_UP
    },

    //  *****************************
    //  Private methods
    //  *****************************

    __loadCodes: function () {
        var codes = {
            'backspace': 8,
            'tab': 9,
            'enter': 13,
            'shift': 16,
            'ctrl': 17,
            'alt': 18,
            'pause/break': 19,
            'caps lock': 20,
            'esc': 27,
            'space': 32,
            'page up': 33,
            'page down': 34,
            'end': 35,
            'home': 36,
            'left': 37,
            'up': 38,
            'right': 39,
            'down': 40,
            'insert': 45,
            'delete': 46,
            'windows': 91,
            'right click': 93,
            'numpad *': 106,
            'numpad +': 107,
            'numpad -': 109,
            'numpad .': 110,
            'numpad /': 111,
            'num lock': 144,
            'scroll lock': 145,
            'my computer': 182,
            'my calculator': 183,
            ';': 186,
            '=': 187,
            ',': 188,
            '-': 189,
            '.': 190,
            '/': 191,
            '`': 192,
            '[': 219,
            '\\': 220,
            ']': 221,
            "'": 222
        };

        for (i = 97; i < 123; i++) codes[String.fromCharCode(i)] = i - 32;
        for (var i = 48; i < 58; i++) codes[i - 48] = i;
        for (i = 1; i < 13; i++) codes['f' + i] = i + 111;
        for (i = 0; i < 10; i++) codes['numpad ' + i] = i + 96;

        var names = {};

        for (i in codes) names[codes[i]] = i;

        for (i = 0; i < 255; i++) {
            this.__keys[i] = KEY_UP;
        }

        this.codes = codes;
        this.names = names;
    },

    __createEvents: function() {

        this.__listeners["keydown"] = function(e) { GE.engine.keyboard.__onKeyDown(e);}.$member();
        this.__listeners["keyup"] = function(e) {GE.engine.keyboard.__onKeyUp(e);}.$member();

    },

    __attachEvents: function () {
        try {
            GE.jQuery.each(this.__listeners, function(k, v) {
                document.addEventListener(k, v, false);
            });
        }
        catch(err) {
            console.log("Error loading "+this.getId()+" "+err);
        }
    },

    __detachEvents: function () {
        try {
            GE.jQuery.each(this.__listeners, function(k, v) {
                document.removeEventListener(k, v, false);
            });

            this.__listeners = {};
        }
        catch(err) {
            console.log("Error unloading "+this.getId()+" "+err);
        }
    },

    __onKeyDown: function (e) {
        var value = this.__keys[e.keyCode];
        if (value == KEY_UP || value == KEY_RELEASED) {
            value = KEY_PRESSED;
            this.__keys[e.keyCode] = value;
        }
    },

    __onKeyUp: function (e) {
        var value = this.__keys[e.keyCode];
        if (value == KEY_DOWN || value == KEY_PRESSED) {
            value = KEY_RELEASED;
            this.__keys[e.keyCode] = value;
        }
    }
});


/**
 * Mouse Buttons.
 * @type {{NONE: number, LEFT: number, MIDDLE: number, RIGHT: number}}
 */
GE.MB = {
    NONE: 0,
    LEFT: 1,
    MIDDLE: 2,
    RIGHT: 3
};
GE.MouseButton = GE.MB;

/**
 * Mouse Button's Status.
 * @type {{UP: number, PRESSED: number, DOWN: number, RELEASED: number}}
 */
GE.MA = {
    UP: 0,
    PRESSED: 1,
    DOWN: 2,
    RELEASED: 3
};

GE.MouseAction = GE.MA;

/**
 *
 * @type {MouseDevices}
 */
GE.MouseDevice = GE.Klass(GE.InputDevice, {

    //  *****************************
    //  Class definitions
    //  *****************************

    $name: "MouseDevice",

    //  *****************************
    //  Attributes
    //  *****************************

    _oldX: 0,
    _oldY: 0,

    x: 0,
    y: 0,

    __timeoutAxis: null,

    __buttonStatus: null,

    //  *****************************
    //  Ctor
    //  *****************************

    initialize: function() {
        this.$super();

        GE.engine.mouse = this;

        this._status = GE.DeviceStatus.CONNECTED;
        this.__buttonStatus = [GE.MA.UP, GE.MA.UP, GE.MA.UP];
        this.__attachEvents();
    },

    //  *****************************
    //  Overrides
    //  *****************************

    start: function() {
        this.$super();

        this._addAxis();

        GE.engine.on(this.getId(), this, GE.Events.Engine.POSUPDATE, function() {

            for (var i = 0; i < this.__buttonStatus.length; i++) {
                switch (this.__buttonStatus[i]) {
                    case GE.MA.PRESSED:
                    {
                        this.__buttonStatus[i] = GE.MA.DOWN;
                    } break;
                    case GE.MA.RELEASED:
                    {
                        this.__buttonStatus[i] = GE.MA.UP;
                    } break;
                }
            }

        }.$member().bind(this));

        return this;
    },

    stop: function() {
        this.$super();
        return this;
    },

    clearAxis: function() {
        this.getAxis(0).clear();
        this.__timeoutAxis = null;
    },

    //  *****************************
    //  Public methods
    //  *****************************

    getPosition: function() {
        return {x: this.x, y: this.y};
    },

    isLeftDown: function() {
        return this.isDown(GE.MB.LEFT);
    },

    isRightDown: function() {
        return this.isDown(GE.MB.RIGHT);
    },

    isPressed: function (key) {
        return this.__buttonStatus[key] == GE.MA.PRESSED;
    },

    isReleased: function (key) {
        return this.__buttonStatus[key] == GE.MA.RELEASED;
    },

    isDown: function (key) {
        return this.__buttonStatus[key] == GE.MA.DOWN;
    },

    isUp: function (key) {
        return this.__buttonStatus[key] == GE.MA.UP;
    },

    //  *****************************
    //  Private methods
    //  *****************************

    __onMouseDown: function (e) {
        var button = this.__getButton(e);
        var value =this.__buttonStatus[button];
        if (value == GE.MA.UP || value == GE.MA.RELEASED) {
            value = GE.MA.PRESSED;
            this.__buttonStatus[button] = value;
        }
    },

    __onMouseUp: function (e) {
        var button = this.__getButton(e);
        var value = this.__buttonStatus[button];
        if (value == GE.MA.DOWN || value == GE.MA.PRESSED) {
            value = GE.MA.RELEASED;
            this.__buttonStatus[button] = value;
        }
    },

    __onMouseMove: function (e) {
        e.preventDefault();

        this._oldX = this.x;
        this._oldY = this.y;

        // The following will translate the mouse coordinates into a number
        // ranging from -1 to 1, where
        //      x == -1 && y == -1 means top-left, and
        //      x ==  1 && y ==  1 means bottom right
        this.x = ( e.clientX / window.innerWidth ) * 2 - 1;
        this.y = - ( e.clientY / window.innerHeight ) * 2 + 1;

        var $this = this;
        if(this.__timeoutAxis) {
            clearTimeout(this.__timeoutAxis);

            var dx = Math.sign(this.x - this._oldX),
                dy = Math.sign(this.y - this._oldY);

            this.getAxis(0).set(dx, dy);
        }

        this.__timeoutAxis = setTimeout(function(){$this.clearAxis();}, 30);
    },

    __attachEvents: function () {

        document.addEventListener('mousemove', function(e){
            GE.engine.mouse.__onMouseMove(e);}.$member(), false);
        document.addEventListener('mousedown', function(e){
            GE.engine.mouse.__onMouseDown(e);}.$member(), false);
        document.addEventListener('mouseup', function(e){
            GE.engine.mouse.__onMouseUp(e);}.$member(), false);

    },

    __getButton: function (e) {
        if ('which' in e) {
            return e.which;
        }
        else {
            // Internet Explorer before version 9
            if ('button' in e) {
                var buttons = "";
                if (e.button & 1) {
                    return GE.MB.LEFT;
                }
                if (e.button & 2) {
                    return GE.MB.RIGHT;
                }
                if (e.button & 4) {
                    return GE.MB.MIDDLE;
                }
            }
        }
        return GE.MB.NONE;
    }

});

